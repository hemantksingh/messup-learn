# Questions to think about before deciding on a DB

* What is the mix of reads and writes? Is your application read heavy or write heavy? Is the datastore read optimized or write optimized? Does your db need to support multiple concurrent writes? Something like a mongodb has Global write lock per db per server - i.e. Multiple concurrent writes will be slow, because queued writes happen in order.

* How much data do you have? Can the data fit on a single machine or in memory?
Disk based solutions are slower, is this your main data store rather than a copy of the data? Redis is an in memory data store but ever so often it persists the data to disk by forking the process (duplicating the data to another process before writing to disk). This can crash your server if it doesn't have 2X the memory as your data.

* Do you need consistency guarantees (transactions)? Do you need authoritative correct answers over availability? What is your weird result tolerance?

* What are your latency and availability requirements - How many concurrent users do you need to support? Are you willing to accept downtime?
  
* What kind of functionality do you require? Do you need strong integrity controls, or are you looking for more flexibility (e.g., schema-less data stores)? Do you require sophisticated reporting or search capabilities? Are your developers more familiar with relational databases than NoSQL?

* Durability or Data loss tolerance - Guarantee that when a client does a write, the server flushes that data to disk before telling the client ok (committed). Writing to disk is expensive than memory. Do you prefer safety over performance? MongoDb does not provide durable writes by default. It does not call fsync, it does not flush to disk before returning to client on a write. Redis is not a durable data store, it occasionally snapshots your data to disk but it can lose writes, therefore it should only be used for caching data or for soft state.
You could possibly afford to miss some writes to a logging data store.

* What are your access patterns? How are you going to query your data? Does your application need to do complicated queries (e.g. JOINS between multiple tables) and is it worth doing those queries inside the application? If you are doing a few primary key lookups then a key value store may just be okay. But if you haven't partitioned your data on the right keys, you might end up loading all the data in a single query and then filtering it to get to your answer.

## Relational Databases

If your data can comfortably fit on a single database server relational database is a good choice. Having said that, there are still ways to handle large amounts of data using a relational database by horizontally distributing your data: Relational database workloads that need to scale their write capacity beyond the constraints of a single DB instance require a different approach

* Replication - same copy of data distributed over multiple nodes. For read-heavy applications, you can also horizontally scale beyond the capacity constraints of a single DB instance by creating one or more read replicas. Read replicas are separate database instances that are replicated asynchronously. As a
result, they are subject to replication lag and might be missing some of the latest transactions.
* Partitioning - Partition data based on functionality over multiples nodes (aka microservices)
* Sharding - Partition data stored in one table's rows into multiple different tables or databases

## NoSql Databases

NoSQL databases trade some of the query and transaction capabilities of relational databases for a more flexible data model that seamlessly scales horizontally.

Size and nature of data: Relational databases store aggregate data in various tables ending up with sliced and diced data. This supports higher order querying capabilities but makes distributing this data across multiple nodes for scalability and performance difficult.

Ease of Development: Aggregate oriented databases get rid of the **aggregate impedance mismatch**. Adoption of NoSql is primarily driven by the ability to rapidly develop new systems. Original idea for looking at alternative to RDBMS was ability to store large amounts of data on distributed nodes, however the initial cost of setting up and configuring an RDBMS also means adoption of NoSql databases can aid agility.

### Aggregate Oriented Databases - Key Value Stores, Document Stores, Column family

In NoSql databases same aggregate is being used to push data back and forth. Aggregate orientation naturally fits in nicely with storing data on large data clusters. This data can be distributed on system clusters. For example in a Shopping Basket scenario Orders and the Line items form an aggregate.
Aggregate orientation is not always a good thing. If the data is sliced in different ways for example querying the revenue generated by a particular Product i.e. individual line items of many orders grouped together by Product. Now the root aggregate becomes the Product.
In relational databases rearranging the data into different structures is quite easy. In an aggregate oriented database (NoSql) this is difficult but still possible. Map reduce jobs rearrange data into different aggregate forms and keep it persistent or may update the data incrementally.

Schema less but implicit schema.

ACID and BASE (Basically available, soft state, eventually consistent)
Graph and relational databases (ACID).
Aggregates are transaction boundaries (BASE). Relational databases prefer consistency over availability.

Conflict resolution is handled by versioning of aggregate data.

## Graph Databases

Nodes and arch graph structure. Makes navigating through relationships easier. Relational dbs and NoSQL dbs lack relationships which makes it difficult to use them for connected data and graphs. Answers to queries like *Who bought a particular product rather than what products a customer bought?* become easier to find.

Underlying storage: native graph storage. Some graph databases however serialize the graph data into a relational db, object-oriented db or some other general purpose data store.
Native graph storage is purpose built for performance and scalability where as a non native graph storage typically depends upon a mature non graph backend (like MySQL) whose production characteristics are well understood by operations team.

The processing engine: Index-free adjacency - connected (adjacent) nodes  contain physical pointers (links) to each other in the db.
Native graph processing (Index free adjaceny)benefits traversal performance but at the expense of making some nontraversal queries difficult or memory intensive.

Use cases for Graph Databases

* **Real-time recommendations**: Recommendation engines powered by graph databases can offer personalized product, content and service suggestions when they leverage the value of data relationships.

* **Fraud detection**: Banks, businesses and insurance companies use graph databases to discover hidden relationships, fraud rings and sophisticated scams.

* **Master data management**: Enterprises uses graph databases to reduce complexity and significantly improve the speed and efficiency of their database applications for both organizational and product management data


## Cloud Spanner  

Based on the [Spanner and CAP Theorem white paper](https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/45855.pdf) Spanner is a globallyâ€‹ distributed database with consistency at scale. With NoSql you trade off consistency for scalability. 

Spanner is technically a CP system but in effect its user can assume it to be CA. No system provides 100% availability, so the pragmatic question is whether or not Spanner delivers availability that is so high that most users don't worry about its outages. For example, given there are many sources of outages for an application, if Spanner is an insignificant contributor to its downtime, then users are correct to not worry about it.

* Use Atomic clocks to synchronise time across Google data centres.
* Uses Open standards - Standard SQL, JDBC drivers
* Monotonically increasing sequence is an anti-pattern for horizontal scaling.
* Imposes limitations on size and number of mutations in a transaction.